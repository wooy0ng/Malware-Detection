import torch.nn as nn
import torch.nn.functional as F
from typing import Callable, Literal, Mapping, Sequence
from numpy.random import RandomState
from sklearn.svm import SVC
from sklearn.ensemble import RandomForestClassifier
from base import BaseModel

class SVMClassificationModel(SVC):
    def __init__(self, 
        *,
        C=1.0,
        kernel="rbf",
        degree=3,
        gamma="scale",
        coef0=0.0,
        shrinking=True,
        probability=False,
        tol=1e-3,
        cache_size=200,
        class_weight=None,
        verbose=False,
        max_iter=-1,
        decision_function_shape="ovr",
        break_ties=False,
        random_state=None             
    ):
        super().__init__(
            C=C,
            kernel=kernel,
            degree=degree,
            gamma=gamma,
            coef0=coef0,
            shrinking=shrinking,
            probability=probability,
            tol=tol,
            cache_size=cache_size,
            class_weight=class_weight,
            verbose=verbose,
            max_iter=max_iter,
            decision_function_shape=decision_function_shape,
            break_ties=break_ties,
            random_state=random_state,
        )
        
    def __str__(self):
        _type = "sklearn"
        return _type + '_'+ self.__class__.__name__

class RandomForestClassificationModel(RandomForestClassifier):
    def __init__(self, 
            n_estimators:int=100, 
            *, 
            criterion="gini", 
            max_depth=None, 
            min_samples_split=2, 
            min_samples_leaf=1, 
            min_weight_fraction_leaf=0, 
            max_features="sqrt", 
            max_leaf_nodes=None, 
            min_impurity_decrease=0, 
            bootstrap=True, 
            oob_score=False, 
            n_jobs=None, 
            random_state=None, 
            verbose=0, 
            warm_start=False,
            class_weight=None, 
            ccp_alpha=0, 
            max_samples=None
        ) -> None:
        super().__init__(n_estimators, 
            criterion=criterion, 
            max_depth=max_depth, 
            min_samples_split=min_samples_split, 
            min_samples_leaf=min_samples_leaf, 
            min_weight_fraction_leaf=min_weight_fraction_leaf, 
            max_features=max_features, 
            max_leaf_nodes=max_leaf_nodes, 
            min_impurity_decrease=min_impurity_decrease, 
            bootstrap=bootstrap, 
            oob_score=oob_score, 
            n_jobs=n_jobs, 
            random_state=random_state, 
            verbose=verbose, 
            warm_start=warm_start, 
            class_weight=class_weight, 
            ccp_alpha=ccp_alpha, 
            max_samples=max_samples
        )

    def __str__(self) -> str:
        _type = "sklearn"
        return _type + '_' + self.__class__.__name__
    
class SampleTorchClassificationModel(BaseModel):
    def __init__(self, in_features, num_classes=2):
        super().__init__()
        self.fc1 = nn.Linear(in_features, num_classes)
        
    def forward(self, x):
        out = self.fc1(x)
        return F.log_softmax(out, dim=-1)